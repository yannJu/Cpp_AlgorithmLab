'''
Minimum Spanning Tree (Kruskalâ€™s Algorithm)
Connected, Weighted, Undirected ê·¸ëž˜í”„ Gê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ê·¸ëž˜í”„ì˜ minimum spanning
tree(MST)ë¥¼ êµ¬í•˜ëŠ” Kruskalì˜ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•˜ì‹œì˜¤.
ì˜ˆë¥¼ ë“¤ì–´, 10ê°œì˜ ë…¸ë“œì™€ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” 19ê°œì˜ ì—ì§€ë¡œ êµ¬ì„±ëœ ì•„ëž˜ ê·¸ëž˜í”„ Gì˜ MST TëŠ” ë‹¤ìŒê³¼
ê°™ë‹¤.
ìœ„ì˜ ê·¸ëž˜í”„ì—ì„œ 9ê°œì˜ ì—ì§€ë¡œ êµ¬ì„±ëœ MST Tì˜ ì—ì§€ì˜ ê°€ì¤‘ì¹˜ì˜ ì´í•©ì€ 37ì´ë‹¤.


ìž…ë ¥
ìž…ë ¥ì€ í‘œì¤€ìž…ë ¥(standard input)ì„ ì‚¬ìš©í•œë‹¤. ìž…ë ¥ì€ t ê°œì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¡œ ì£¼ì–´ì§„ë‹¤. ìž…ë ¥ íŒŒì¼ì˜
ì²« ë²ˆì§¸ ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ê°œìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ t ê°€ ì£¼ì–´ì§„ë‹¤. ë‘ ë²ˆì§¸ ì¤„ë¶€í„° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ê°€
ìž…ë ¥ëœë‹¤. ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— í•´ë‹¹ë˜ëŠ” ê° ì¤„ì—ëŠ” ê·¸ëž˜í”„ì˜ ë…¸ë“œì˜ ê°œìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ ð‘›ð‘› (3 â‰¤
ð‘›ð‘› â‰¤ 1000) ì´ ì£¼ì–´ì§„ë‹¤. ê·¸ ë‹¤ìŒ n ê°œì˜ ì¤„ì—ëŠ” í•œ ì¤„ì— í•˜ë‚˜ì˜ ë…¸ë“œ ð‘˜ð‘˜ (1 â‰¤ ð‘˜ð‘˜ â‰¤ ð‘›ð‘›) ì— ì¸ì ‘í•œ ë…¸ë“œì™€
ë²ˆí˜¸ì™€ ê·¸ ë…¸ë“œì— ì—°ê²°ëœ ì—ì§€ì˜ ê°€ì¤‘ì¹˜ê°€ ì£¼ì–´ì§„ë‹¤. ê° ì¤„ì—ëŠ” ë¨¼ì € ë…¸ë“œ ë²ˆí˜¸ ð‘˜ð‘˜ (1 â‰¤ ð‘˜ð‘˜ â‰¤ ð‘›ð‘›) ê°€ ì£¼ì–´
ì§€ê³ , ê·¸ ë‹¤ìŒì—ëŠ” ë…¸ë“œ kì— ì¸ì ‘í•œ ë…¸ë“œë“¤ì˜ ê°œìˆ˜ ð‘šð‘š (1 â‰¤ ð‘šð‘š â‰¤ ð‘›ð‘› âˆ’ 1) ì´ ì£¼ì–´ì§„ë‹¤. ê·¸ ë‹¤ìŒì—ëŠ” 2m
ê°œì˜ ì •ìˆ˜ ð‘£ð‘£1 ð‘¤ð‘¤1 ð‘£ð‘£2 ð‘¤ð‘¤2 â‹¯ ð‘£ð‘£ð‘šð‘š ð‘¤ð‘¤ð‘šð‘š ê°€ ì£¼ì–´ì§€ëŠ”ë°, ð‘£ð‘£1, ð‘£ð‘£2 , â‹¯ , ð‘£ð‘£ð‘šð‘š ì€ ë…¸ë“œ kì— ì¸ì ‘í•œ ë…¸ë“œë“¤ì˜ ë²ˆí˜¸ì´ê³ 
ð‘¤ð‘¤1, ð‘¤ð‘¤2 , â‹¯ , ð‘¤ð‘¤ð‘šð‘š ì€ í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ëœ ì—ì§€ì˜ ê°€ì¤‘ì¹˜ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. ê°€ì¤‘ì¹˜ì˜ ìµœëŒ€ëŠ” 100ì´ë©° ìµœì†ŒëŠ” 1
ì´ë‹¤. ê° ì •ìˆ˜ë“¤ ì‚¬ì´ì—ëŠ” í•œ ê°œì˜ ê³µë°±ì´ ìžˆìœ¼ë©°, ìž˜ëª»ëœ ë°ì´í„°ê°€ ìž…ë ¥ë˜ëŠ” ê²½ìš°ëŠ” ì—†ë‹¤.
Â© Copyright 2021 by Joonsoo Choi. All Rights Reserved.
ì¶œë ¥
ì¶œë ¥ì€ í‘œì¤€ì¶œë ¥(standard output)ì„ ì‚¬ìš©í•œë‹¤. ìž…ë ¥ë˜ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ìˆœì„œëŒ€ë¡œ ë‹¤ìŒ ì¤„ì— ì´ì–´
ì„œ ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ê²°ê³¼ë¥¼ ì¶œë ¥í•œë‹¤. ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— í•´ë‹¹í•˜ëŠ” ì¶œë ¥ì˜ ì²« ì¤„ì— ìž…ë ¥ë˜ëŠ” ê·¸ëž˜
í”„ì˜ MSTì˜ ì—ì§€ì˜ ì´í•©ì„ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤.
ìž…ë ¥ê³¼ ì¶œë ¥ì˜ ì˜ˆ
ìž…ë ¥
3
10
1 3 2 9 3 8 4 5
2 3 1 9 5 7 6 9
3 5 1 8 4 3 5 2 7 3 8 5
4 3 1 5 3 3 8 7
5 4 2 7 3 2 6 5 7 4
6 5 2 9 5 5 7 6 9 9 10 8
7 5 3 3 5 4 6 6 8 4 9 7
8 4 3 5 4 7 7 4 9 4
9 4 6 9 7 7 8 4 10 3
10 2 6 8 9 3
5
1 3 2 1 4 8 5 5
2 2 1 1 3 6
3 1 2 6
4 1 1 8
5 1 1 5
5
1 4 2 20 3 12 4 12 5 8
2 3 1 20 3 17 4 5
3 3 1 12 2 17 5 6
4 3 1 12 2 5 5 5
5 3 1 8 3 6 4 5
ì¶œë ¥
36
20
24
'''

import sys

def findSet(pr, idx):
    if idx != pr[idx]: pr[idx] = findSet(pr, pr[idx])
    return pr[idx]

def KRUSKAL(G, n):
    sum = 0 #A
    G_V = list()
    parent = list()
    G_E = sorted(G.items(), key=lambda x: x[1])
    for i in range(n + 1): G_V.append([i]); #Make_set
    for i in range(n + 1): parent.append(i); #parent
    
    for ge in range(len(G_E)):
        geUV = G_E[ge][0]
        uIdx = findSet(parent, geUV[0]); vIdx = findSet(parent, geUV[1]) 
        if (uIdx > vIdx):
            tmp = uIdx
            uIdx = vIdx
            vIdx = tmp
            
        if (uIdx != vIdx):
            sum += G_E[ge][1]
            parent[vIdx] = parent[uIdx]
    print(sum)

t_case = int(input())
for t in range(t_case):
    nodes = int(input())
    adjMatrix = dict()
    for n in range(1, nodes + 1):
        tmp = list(map(int, sys.stdin.readline().split()))
        for i in range(2, len(tmp), 2): 
            if (tmp[i] > n): adjMatrix[((n, tmp[i]))] = tmp[i + 1]
    
    KRUSKAL(adjMatrix, nodes)